---
// Import proper Starlight utilities
const t = (key: string) => {
	const translations = {
		'themeSelect.accessibleLabel': 'Select theme',
		'themeSelect.light': 'Light',
		'themeSelect.dark': 'Dark',
		'themeSelect.auto': 'Auto',
	};
	return translations[key as keyof typeof translations] || key;
};
---

<starlight-theme-select>
	<label>
		<span class="sr-only">{t('themeSelect.accessibleLabel')}</span>
		<svg class="icon light" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
			<path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12ZM11 1h2v3h-2V1Zm0 19h2v3h-2v-3ZM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93ZM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121Zm2.121-14.85 1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121ZM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121ZM23 11v2h-3v-2h3ZM4 11v2H1v-2h3Z"/>
		</svg>
		<svg class="icon dark" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
			<path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.69 4.27 1.8 1.09 1.11 1.76 2.63 1.76 4.29 0 .71-.15 1.38-.42 2 .14 0 .28.02.42.02 5.41 0 9.8-4.28 9.99-9.65-1.59 1.03-5.55 2.93-10.01-.53Z"/>
		</svg>
		<svg class="icon auto" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
			<path d="M4 6h16v2H4V6Zm0 5h16v2H4v-2Zm0 5h16v2H4v-2Z"/>
		</svg>
		<select value="auto">
			<option value="light">{t('themeSelect.light')}</option>
			<option value="dark">{t('themeSelect.dark')}</option>
			<option value="auto">{t('themeSelect.auto')}</option>
			<option value="blue">Blue Ocean</option>
			<option value="forest">Forest Green</option>
			<option value="sunset">Sunset Orange</option>
			<option value="purple">Purple Night</option>
		</select>
	</label>
</starlight-theme-select>

<script>
class StarlightThemeSelect extends HTMLElement {
	private mediaQuery: MediaQueryList | null = null;

	constructor() {
		super();

		// Set up system preference listener BEFORE applying theme
		if (typeof matchMedia !== 'undefined') {
			this.mediaQuery = matchMedia('(prefers-color-scheme: dark)');
			this.mediaQuery.addEventListener('change', this.handleSystemThemeChange);
		}

		// Apply initial theme
		this.onThemeChange(this.getTheme());

		// Attach event listener after initialization
		this.querySelector('select')?.addEventListener('change', (e) => {
			if (e.currentTarget instanceof HTMLSelectElement) {
				this.onThemeChange(this.parseTheme(e.currentTarget.value));
			}
		});
	}

	/** Get a typesafe theme string from any JS value (unknown values are coerced to `'auto'`). */
	parseTheme(theme: unknown): 'light' | 'dark' | 'auto' | 'blue' | 'forest' | 'sunset' | 'purple' {
		if (theme === 'light' || theme === 'dark' || theme === 'auto' ||
		    theme === 'blue' || theme === 'forest' || theme === 'sunset' || theme === 'purple') {
			return theme;
		} else {
			return 'auto';
		}
	}

	/** Get the current theme setting. */
	getTheme() {
		return this.parseTheme(
			typeof localStorage !== 'undefined' && localStorage.getItem('starlight-theme')
		);
	}

	/** Update select menu UI, document theme, and local storage state. */
	onThemeChange(theme: ReturnType<StarlightThemeSelect['parseTheme']>) {
		this.updateSelectionUI(theme);
		this.updateTheme(theme);
		if (typeof localStorage !== 'undefined') {
			localStorage.setItem('starlight-theme', theme);
		}
	}

	/** Set the selection UI state. */
	updateSelectionUI(theme: ReturnType<StarlightThemeSelect['parseTheme']>) {
		const select = this.querySelector('select');
		if (select) select.value = theme;
	}

	/** Update the document theme. */
	updateTheme(theme: ReturnType<StarlightThemeSelect['parseTheme']>) {
		const doc = document.documentElement;

		// Remove all theme classes and data-theme attribute
		doc.classList.remove('theme-light', 'theme-dark', 'theme-blue', 'theme-forest', 'theme-sunset', 'theme-purple');
		doc.removeAttribute('data-theme');

		// Apply the new theme - consistently use both data-theme and classes
		if (theme === 'light') {
			doc.setAttribute('data-theme', 'light');
			doc.classList.add('theme-light');
		} else if (theme === 'dark') {
			doc.setAttribute('data-theme', 'dark');
			doc.classList.add('theme-dark');
		} else if (theme === 'auto') {
			// For auto, detect system preference
			const systemPrefersDark = this.mediaQuery ? this.mediaQuery.matches :
				(typeof matchMedia !== 'undefined' && matchMedia('(prefers-color-scheme: dark)').matches);

			if (systemPrefersDark) {
				doc.setAttribute('data-theme', 'dark');
				doc.classList.add('theme-dark');
			} else {
				doc.setAttribute('data-theme', 'light');
				doc.classList.add('theme-light');
			}
		} else if (theme === 'blue') {
			doc.setAttribute('data-theme', 'blue');
			doc.classList.add('theme-blue');
		} else if (theme === 'forest') {
			doc.setAttribute('data-theme', 'forest');
			doc.classList.add('theme-forest');
		} else if (theme === 'sunset') {
			doc.setAttribute('data-theme', 'sunset');
			doc.classList.add('theme-sunset');
		} else if (theme === 'purple') {
			doc.setAttribute('data-theme', 'purple');
			doc.classList.add('theme-purple');
		}
	}

	/** Cleanup method for removing event listeners */
	disconnectedCallback() {
		if (this.mediaQuery) {
			// Note: MediaQueryList.removeEventListener might not be available in all browsers
			// This is a safeguard for proper cleanup
			try {
				this.mediaQuery.removeEventListener('change', this.handleSystemThemeChange);
			} catch (e) {
				// Fallback: removeListener is deprecated but more widely supported
				if ('removeListener' in this.mediaQuery) {
					(this.mediaQuery as any).removeListener(this.handleSystemThemeChange);
				}
			}
		}
	}

	/** Bound method for system theme change handling */
	private handleSystemThemeChange = () => {
		if (this.getTheme() === 'auto') {
			this.updateTheme('auto');
		}
	}
}

customElements.define('starlight-theme-select', StarlightThemeSelect);
</script>

<style>
	label {
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
		width: 2.5rem;
		height: 2.5rem;
		color: var(--sl-color-gray-2);
		cursor: pointer;
		border-radius: 0.25rem;
	}

	label:hover {
		color: var(--sl-color-gray-1);
	}

	.icon {
		position: absolute;
		font-size: 1.125rem;
		width: 1em;
		height: 1em;
	}

	select {
		position: absolute;
		border: 0;
		width: 100%;
		height: 100%;
		padding: 0;
		margin: 0;
		z-index: 2;
		cursor: pointer;
		opacity: 0;
	}

	/* Icon visibility based on theme */
	.icon {
		opacity: 0.6;
	}

	/* Light theme shows light icon */
	:global([data-theme='light']) .icon.light,
	:global(.theme-light) .icon.light {
		opacity: 1;
		color: var(--sl-color-accent);
	}

	/* Dark theme shows dark icon */
	:global([data-theme='dark']) .icon.dark,
	:global(.theme-dark) .icon.dark {
		opacity: 1;
		color: var(--sl-color-accent);
	}

	/* Custom themes show light icon (consolidated) */
	:global([data-theme='blue']) .icon.light,
	:global([data-theme='forest']) .icon.light,
	:global([data-theme='sunset']) .icon.light,
	:global([data-theme='purple']) .icon.light,
	:global(.theme-blue) .icon.light,
	:global(.theme-forest) .icon.light,
	:global(.theme-sunset) .icon.light,
	:global(.theme-purple) .icon.light {
		opacity: 1;
		color: var(--sl-color-accent);
	}

	/* Hide inactive icons */
	:global([data-theme='light']) .icon:not(.light),
	:global([data-theme='dark']) .icon:not(.dark),
	:global([data-theme='blue']) .icon:not(.light),
	:global([data-theme='forest']) .icon:not(.light),
	:global([data-theme='sunset']) .icon:not(.light),
	:global([data-theme='purple']) .icon:not(.light),
	:global(.theme-light) .icon:not(.light),
	:global(.theme-dark) .icon:not(.dark),
	:global(.theme-blue) .icon:not(.light),
	:global(.theme-forest) .icon:not(.light),
	:global(.theme-sunset) .icon:not(.light),
	:global(.theme-purple) .icon:not(.light) {
		opacity: 0.3;
	}

	@media (forced-colors: active) {
		.icon {
			filter: invert(1);
		}
	}
</style>
